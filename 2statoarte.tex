La crescente popolarità dell’approccio multi-cloud ha portato alla nascita di varie tecnologie che ne permettano l’utilizzo, ognuna delle quali utilizza un approccio specifico in base agli obiettivi che si pone. Inizialmente lo scopo degli strumenti era quello di fornire un modo per unificare la gestione e il controllo delle varie risorse fornite dai diversi provider, raggruppandole sotto un unico ambiente. È il caso di OpenStack \cite{OpenStack}, un software open-source rilasciato sotto licenza Apache che opera come un sistema operativo per Cloud. OpenStack permette di creare e gestire ambienti Cloud, sia pubblici che privati, attraverso risorse virtuali relative al modello IaaS, di conseguenza manca il supporto agli altri modelli, soprattutto al Serverless Computing. Un approccio simile è seguito da MODAClouds \cite{MODAClouds}, un framework che segue un approccio model-driven per la progettazione e l’esecuzione di applicazioni multi-cloud. Il punto di forza è il suo approccio model-driven che consente di progettare le applicazioni ad alto livello, in completa astrazione rispetto al Cloud di riferimento, e poterle eseguire su qualsiasi piattaforma. Il codice in questione viene infatti tradotto in base all’ambiente di esecuzione permettendo una facile integrazione di più servizi Cloud e rendendo particolarmente semplice la migrazione delle applicazioni da provider a provider. \\
Con l’avvento del Serverless Computing è nata la necessità di estendere gli strumenti esistenti per supportare questo modello. È il caso di TOSCA \cite{TOSCASite}, acronimo per
Topology and Orchestration Specification for Cloud Applications, un linguaggio di standard OASIS per la modellazione per lo sviluppo e la gestione di applicazioni su Cloud. In \citet{TOSCAServerless} viene esteso per integrare la possibilità di sfruttare le componenti Serverless all’interno delle applicazioni che si vuole creare. TOSCA permette di descrivere la struttura e il comportamento dei servizi forniti dal Cloud concentrandosi su portabilità e interoperabilità delle applicazioni descritte, risultando tuttavia mancante di alcune funzionalità critiche per le applicazioni Cloud in quanto non permette di specificare i requisiti di risorse. Un approccio molto simile è quello di CAMEL \cite{CAMELSite}, un Multi-Domain-Specific Language per la gestione del ciclo di vita delle applicazioni. Acronimo di Cloud Application Modelling and Execution Language, CAMEL consente di modellare componenti per applicazioni o servizi sfruttando più ambienti Cloud. Anche in questo caso il linguaggio viene esteso in \citet{@ServerlessCamel} che introduce un’estensione che supporti le componenti Serverless. CAMEL è un multi-DSL, l’unione di diversi DSL per coprire tutti gli aspetti del ciclo di vita di un’applicazione, ed è basato sulla tecnologia Xtext di Eclipse.
Basato su CAMEL MELODIC \cite{MELODIC} è un middleware che permette di automatizzare ed ottimizzare lo sviluppo di applicazioni multi-cloud. Tutte le componenti di MELODIC non sono legate ad un particolare Cloud provider ma possono essere utilizzate per qualsiasi ambiente su Cloud. L'integrazione all'interno di MELODIC del supporto alle componenti Serverless è descritto in \citet{ServerlessMultiCloud}. \\
Un altro tipo di soluzioni è quello dedicato esclusivamente alle componenti Serverless, di cui l’esponente maggiore è certamente Serverless \cite{ServerlessSite}, un framework web open-source scritto in Node.js. Serverless è il primo framework sviluppato per la costruzione di applicazioni basate sui servizi di Serverless Computing offerte dai principali Cloud provider, sono infatti supportati AWS Lambda di AWS, Azure Function di Microsoft Azure, IBM Bluemix e Google Cloud Platform. Serverless fornisce una CLI, Command Line Interface, per sviluppare le varie applicazioni fornendo esempi, strutture pre-costruite per agevolare il lavoro dello sviluppatore. Supportando tutti i maggiori Cloud provider, la Serverless Framework CLI fornisce un’esperienza di sviluppo singola per diversi provider. Punto a favore è la possibilità di testare le proprio applicazioni in locale, senza necessità di interagire con il provider, evitando quindi di incorrere in costi di esecuzione. Al contrario il limite di Serverless è proprio la specificità di servizio, dedicato alla costruzione di applicazioni puramente Serverless. \\
Un approccio diverso è proposto in \citet{DistributedFaas} in cui viene descritta un’architettura basata su container che permette di progettare e costruire un sistema distribuito tra diversi Cloud provider sul modello FaaS. Questa può essere vista come un’integrazione dei classici sistemi di High Performance Computing, formati da cluster di computer, declinati sul modello FaaS. Quello che si ottiene sono meccanismi di auto-scaling sia per macchine virtuali che per container in un ambiente distribuito multi-cloud, in aggiunta ad un sistema di bilanciamento del carico che tiene conto dei diversi cluster FaaS coinvolti. 
